<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Uniswap V4 Fee Checker</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }
    .input-group {
      margin-bottom: 10px;
    }
    label {
      display: inline-block;
      width: 150px;
    }
    input, button {
      padding: 5px;
      margin: 5px;
    }
    #output {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Uniswap V4 Fee Checker</h1>

  <div class="input-group">
    <label>LP NFT ID:</label>
    <input type="number" id="tokenId" value="85000">
  </div>
  <div style="display:none;">
  <div class="input-group">
    <label>Token0 Price (USD):</label>
    <input type="number" id="token0Price" value="0" placeholder="Enter Token0 price in USD (optional override)">
  </div>
  <div class="input-group">
    <label>Token1 Price (USD):</label>
    <input type="number" id="token1Price" value="0" placeholder="Enter Token1 price in USD (optional override)">
  </div>
  <div class="input-group">
    <label>Infura API Key (optional):</label>
    <input type="text" id="infuraKey" value="" placeholder="Enter Infura API Key (optional)">
  </div>
  </div>

  <button onclick="checkFees()">Check Fees</button>
  <div id="output">Results will appear here...</div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.0/dist/ethers.umd.js"></script>
  <script>
    if (typeof ethers === 'undefined') {
      document.getElementById('output').textContent = 'Error: ethers.js failed to load.';
      throw new Error('ethers.js not defined');
    }

    const POSITION_MANAGER = '0xbd216513d74c8cf14cf4747e6aaa6420ff64ee9e';
    const STATE_VIEW = '0x7ffe42c4a5deea5b0fec41c94c136cf115597227';
    const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
    const WETH_ADDRESS = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
    const USDC_ADDRESS = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';
    const V3_FACTORY = '0x1F98431c8aD98523631AE4a59f267346ea31F984';
    const V2_FACTORY = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f';

    const publicRpcs = [
      'https://eth.llamarpc.com',
      'https://eth.drpc.org',
      'https://eth-mainnet.public.blastapi.io',
      'https://rpc.payload.de',
      'https://rpc.poolz.finance/eth',
      'https://0xrpc.io/eth',
      'https://1rpc.io/eth',
      'https://api.zan.top/eth-mainnet',
      'https://rpc.flashbots.net',
      'https://rpc.flashbots.net/fast',
      'https://eth1.lava.build',
      'https://rpc.mevblocker.io',
      'https://api.zan.top/eth-mainnet'
    ];

    const positionManagerAbi = [
      {
        "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
        "name": "getPoolAndPositionInfo",
        "outputs": [
          {
            "components": [
              {"internalType": "address", "name": "currency0", "type": "address"},
              {"internalType": "address", "name": "currency1", "type": "address"},
              {"internalType": "uint24", "name": "fee", "type": "uint24"},
              {"internalType": "int24", "name": "tickSpacing", "type": "int24"},
              {"internalType": "address", "name": "hooks", "type": "address"}
            ],
            "name": "poolKey",
            "type": "tuple"
          },
          {"internalType": "uint256", "name": "info", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
        "name": "ownerOf",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const stateViewAbi = [
      {
        "inputs": [
          {"internalType": "bytes32", "name": "", "type": "bytes32"},
          {"internalType": "address", "name": "", "type": "address"},
          {"internalType": "int24", "name": "", "type": "int24"},
          {"internalType": "int24", "name": "", "type": "int24"},
          {"internalType": "bytes32", "name": "", "type": "bytes32"}
        ],
        "name": "getPositionInfo",
        "outputs": [
          {"internalType": "uint128", "name": "liquidity", "type": "uint128"},
          {"internalType": "uint256", "name": "feeGrowthInside0LastX128", "type": "uint256"},
          {"internalType": "uint256", "name": "feeGrowthInside1LastX128", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {"internalType": "bytes32", "name": "", "type": "bytes32"},
          {"internalType": "int24", "name": "", "type": "int24"},
          {"internalType": "int24", "name": "", "type": "int24"}
        ],
        "name": "getFeeGrowthInside",
        "outputs": [
          {"internalType": "uint256", "name": "feeGrowthInside0X128", "type": "uint256"},
          {"internalType": "uint256", "name": "feeGrowthInside1X128", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const erc20Abi = [
      {"inputs": [], "name": "decimals", "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"}
    ];

    const v3FactoryAbi = [
      {
        "inputs": [
          {"internalType": "address", "name": "tokenA", "type": "address"},
          {"internalType": "address", "name": "tokenB", "type": "address"},
          {"internalType": "uint24", "name": "fee", "type": "uint24"}
        ],
        "name": "getPool",
        "outputs": [{"internalType": "address", "name": "pool", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const v3PoolAbi = [
      {
        "inputs": [],
        "name": "slot0",
        "outputs": [
          {"internalType": "uint160", "name": "sqrtPriceX96", "type": "uint160"},
          {"internalType": "int24", "name": "tick", "type": "int24"},
          {"internalType": "uint16", "name": "observationIndex", "type": "uint16"},
          {"internalType": "uint16", "name": "observationCardinality", "type": "uint16"},
          {"internalType": "uint16", "name": "observationCardinalityNext", "type": "uint16"},
          {"internalType": "uint8", "name": "feeProtocol", "type": "uint8"},
          {"internalType": "bool", "name": "unlocked", "type": "bool"}
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "token0",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "token1",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const v2FactoryAbi = [
      {
        "inputs": [
          {"internalType": "address", "name": "tokenA", "type": "address"},
          {"internalType": "address", "name": "tokenB", "type": "address"}
        ],
        "name": "getPair",
        "outputs": [{"internalType": "address", "name": "pair", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const v2PairAbi = [
      {
        "inputs": [],
        "name": "getReserves",
        "outputs": [
          {"internalType": "uint112", "name": "reserve0", "type": "uint112"},
          {"internalType": "uint112", "name": "reserve1", "type": "uint112"},
          {"internalType": "uint32", "name": "blockTimestampLast", "type": "uint32"}
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "token0",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "token1",
        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    function bigDivToDecimal(num, den, precision = 10) {
      if (den === 0n) return 0;
      let intPart = (num / den).toString();
      let rem = num % den;
      if (rem === 0n) return parseFloat(intPart);
      let frac = '.';
      for (let i = 0; i < precision; i++) {
        rem = rem * 10n;
        let digit = Number(rem / den);
        frac += digit.toString();
        rem = rem % den;
        if (rem === 0n) break;
      }
      return parseFloat(intPart + frac);
    }

    async function getFastestProvider(rpcs) {
      const testPromises = rpcs.map(async (url) => {
        const start = performance.now();
        let provider;
        try {
          provider = new ethers.JsonRpcProvider(url);
          await provider.getBlockNumber();
          const end = performance.now();
          return { provider, latency: end - start };
        } catch (e) {
          return null;
        }
      });

      const results = await Promise.all(testPromises);
      const validResults = results.filter(r => r !== null);
      if (validResults.length === 0) {
        throw new Error('No valid public RPC available');
      }
      return validResults.reduce((fastest, current) => 
        current.latency < fastest.latency ? current : fastest
      ).provider;
    }

    async function get_eth_usd(provider) {
      try {
        const v3Factory = new ethers.Contract(V3_FACTORY, v3FactoryAbi, provider);
        const fees = [500, 3000, 10000];
        for (let fee of fees) {
          const poolAddr = await v3Factory.getPool(USDC_ADDRESS, WETH_ADDRESS, fee);
          if (poolAddr === ethers.ZeroAddress) continue;
          const pool = new ethers.Contract(poolAddr, v3PoolAbi, provider);
          const [sqrtPriceX96] = await pool.slot0();
          if (sqrtPriceX96 === 0n) continue;
          const sqrtPriceX96BI = BigInt(sqrtPriceX96);
          const num = (1n << 192n) * (10n ** 12n);
          const den = sqrtPriceX96BI * sqrtPriceX96BI;
          const price = bigDivToDecimal(num, den, 10);
          return price;
        }
        return 0;
      } catch (e) {
        console.warn('ETH USD fetch failed:', e);
        return 0;
      }
    }

    async function get_decimals(token, provider) {
      const tokenAddr = ethers.getAddress(token);
      if (tokenAddr === ZERO_ADDRESS || tokenAddr.toLowerCase() === WETH_ADDRESS.toLowerCase()) {
        return 18;
      }
      try {
        const erc20 = new ethers.Contract(tokenAddr, erc20Abi, provider);
        return Number(await erc20.decimals());
      } catch (e) {
        console.warn('Decimals fetch failed:', e);
        return 18;
      }
    }

    async function get_token_price(token, provider, manualPrice = 0) {
      if (manualPrice > 0) return manualPrice;
      let tokenAddr = ethers.getAddress(token);
      if (tokenAddr === ZERO_ADDRESS || tokenAddr.toLowerCase() === WETH_ADDRESS.toLowerCase()) {
        return await get_eth_usd(provider);
      }
      const tokenDecimals = await get_decimals(tokenAddr, provider);
      const wethDecimals = 18;
      const ethUsd = await get_eth_usd(provider);
      if (ethUsd === 0) return 0;
      const diff = tokenDecimals - wethDecimals;
      const absDiff = Math.abs(diff);
      const pow10 = 10n ** BigInt(absDiff);
      const fees = [3000, 500, 10000];
      // Try V3
      try {
        const v3Factory = new ethers.Contract(V3_FACTORY, v3FactoryAbi, provider);
        for (let fee of fees) {
          const poolAddr = await v3Factory.getPool(tokenAddr, WETH_ADDRESS, fee);
          if (poolAddr === ethers.ZeroAddress) continue;
          const pool = new ethers.Contract(poolAddr, v3PoolAbi, provider);
          const [sqrtPriceX96] = await pool.slot0();
          if (sqrtPriceX96 === 0n) continue;
          const sqrtPriceX96BI = BigInt(sqrtPriceX96);
          const t0 = await pool.token0();
          let num, den;
          if (t0.toLowerCase() === tokenAddr.toLowerCase()) {
            num = sqrtPriceX96BI * sqrtPriceX96BI;
            den = (1n << 96n) * (1n << 96n);
          } else {
            num = (1n << 96n) * (1n << 96n);
            den = sqrtPriceX96BI * sqrtPriceX96BI;
          }
          if (diff >= 0) {
            num = num * pow10;
          } else {
            den = den * pow10;
          }
          const priceInWeth = bigDivToDecimal(num, den, 10);
          return priceInWeth * ethUsd;
        }
      } catch (e) {
        console.warn('V3 price fetch failed:', e);
      }
      // Fallback to V2
      try {
        const v2Factory = new ethers.Contract(V2_FACTORY, v2FactoryAbi, provider);
        const pairAddr = await v2Factory.getPair(tokenAddr, WETH_ADDRESS);
        if (pairAddr === ethers.ZeroAddress) return 0;
        const pair = new ethers.Contract(pairAddr, v2PairAbi, provider);
        const [reserve0, reserve1] = await pair.getReserves();
        if (reserve0 === 0n || reserve1 === 0n) return 0;
        const t0 = await pair.token0();
        let num, den;
        if (t0.toLowerCase() === tokenAddr.toLowerCase()) {
          num = reserve1;
          den = reserve0;
        } else {
          num = reserve0;
          den = reserve1;
        }
        if (diff >= 0) {
          num = num * pow10;
        } else {
          den = den * pow10;
        }
        const priceInWeth = bigDivToDecimal(num, den, 10);
        return priceInWeth * ethUsd;
      } catch (e) {
        console.warn('V2 price fetch failed:', e);
        return 0;
      }
    }

    async function checkFees() {
      const output = document.getElementById('output');
      output.textContent = 'Fetching data...';

      try {
        const tokenId = parseInt(document.getElementById('tokenId').value) || 85000;
        let token0Manual = parseFloat(document.getElementById('token0Price').value) || 0;
        let token1Manual = parseFloat(document.getElementById('token1Price').value) || 0;
        const infuraKey = document.getElementById('infuraKey').value.trim();

        let provider;
        if (infuraKey) {
          const rpcUrl = `https://mainnet.infura.io/v3/${infuraKey}`;
          provider = new ethers.JsonRpcProvider(rpcUrl);
        } else {
          provider = await getFastestProvider(publicRpcs);
        }

        const positionManager = new ethers.Contract(POSITION_MANAGER, positionManagerAbi, provider);
        const stateView = new ethers.Contract(STATE_VIEW, stateViewAbi, provider);

        // Owner check
        let owner;
        try {
          owner = await positionManager.ownerOf(tokenId);
          if (owner === ZERO_ADDRESS) {
            output.textContent = `Position ${tokenId} is burned (no owner).`;
            return;
          }
        } catch (e) {
          output.textContent = `Position ${tokenId} not minted.`;
          return;
        }

        // Pool info
        let poolKey, info;
        [poolKey, info] = await positionManager.getPoolAndPositionInfo(tokenId);

        info = BigInt(info);
        let tickUpper = Number((info >> 32n) & 0xffffffn);
        let tickLower = Number((info >> 8n) & 0xffffffn);
        if (tickUpper >= 0x800000) tickUpper -= 0x1000000;
        if (tickLower >= 0x800000) tickLower -= 0x1000000;

        const poolKeyEncoded = ethers.AbiCoder.defaultAbiCoder().encode(
          ['tuple(address,address,uint24,int24,address)'],
          [[poolKey.currency0, poolKey.currency1, poolKey.fee, poolKey.tickSpacing, poolKey.hooks]]
        );
        const poolId = ethers.keccak256(poolKeyEncoded);
        const salt = ethers.zeroPadValue(ethers.toBeHex(tokenId), 32);

        // Position info
        const [liquidity, feeGrowthInside0Last, feeGrowthInside1Last] = await stateView.getPositionInfo(
          poolId, POSITION_MANAGER, tickLower, tickUpper, salt
        );
        const [feeGrowthInside0Current, feeGrowthInside1Current] = await stateView.getFeeGrowthInside(
          poolId, tickLower, tickUpper
        );

        // --- SAFE BIGINT MATH ---
        const Q128 = 1n << 128n;
        const liquidityBI = BigInt(liquidity);
        const feeGrowthInside0CurrentBI = BigInt(feeGrowthInside0Current);
        const feeGrowthInside0LastBI = BigInt(feeGrowthInside0Last);
        const feeGrowthInside1CurrentBI = BigInt(feeGrowthInside1Current);
        const feeGrowthInside1LastBI = BigInt(feeGrowthInside1Last);

        const token0Fees = feeGrowthInside0CurrentBI >= feeGrowthInside0LastBI
          ? (feeGrowthInside0CurrentBI - feeGrowthInside0LastBI) * liquidityBI / Q128
          : 0n;
        const token1Fees = feeGrowthInside1CurrentBI >= feeGrowthInside1LastBI
          ? (feeGrowthInside1CurrentBI - feeGrowthInside1LastBI) * liquidityBI / Q128
          : 0n;

        // --- TOKEN DECIMALS ---
        let token0Decimals = 18;
        let token1Decimals = 18;
        let token0Name = poolKey.currency0 === ZERO_ADDRESS ? 'ETH' : poolKey.currency0;
        let token1Name = poolKey.currency1 === ZERO_ADDRESS ? 'ETH' : poolKey.currency1;

        if (poolKey.currency0 !== ZERO_ADDRESS) {
          try {
            const token0Contract = new ethers.Contract(poolKey.currency0, erc20Abi, provider);
            token0Decimals = Number(await token0Contract.decimals());
          } catch (e) { console.warn("Token0 decimals fetch failed:", e); }
        }
        if (poolKey.currency1 !== ZERO_ADDRESS) {
          try {
            const token1Contract = new ethers.Contract(poolKey.currency1, erc20Abi, provider);
            token1Decimals = Number(await token1Contract.decimals());
          } catch (e) { console.warn("Token1 decimals fetch failed:", e); }
        }

        // --- FORMAT UNITS (no precision loss) ---
        const token0FeesAdj = parseFloat(ethers.formatUnits(token0Fees, token0Decimals));
        const token1FeesAdj = parseFloat(ethers.formatUnits(token1Fees, token1Decimals));

        // Fetch live USD prices (on-chain, with manual override)
        const token0PriceUSD = await get_token_price(poolKey.currency0, provider, token0Manual);
        const token1PriceUSD = await get_token_price(poolKey.currency1, provider, token1Manual);

        const token0Usd = token0FeesAdj * token0PriceUSD;
        const token1Usd = token1FeesAdj * token1PriceUSD;
        const totalUsd = token0Usd + token1Usd;
        output.textContent =
          `✅ Position ${tokenId}\n` +
          `Owner: ${owner}\n\n` +
	  `Token0 (${token0Name}): ${token0FeesAdj}\n (Price: ${token0PriceUSD} USD: ${token0Usd.toFixed(2)})\n` +
          `Token1 (${token1Name}): ${token1FeesAdj}\n (Price: ${token1PriceUSD} USD: ${token1Usd.toFixed(2)})\n` +
          `Total USD: ${totalUsd.toFixed(2)}`;
      } catch (e) {
        document.getElementById('output').textContent = `❌ Error: ${e.message}`;
        console.error(e);
      }
    }
  </script>
</body>
</html>
